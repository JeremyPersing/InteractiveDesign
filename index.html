<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      body {
        font-family: Arial, Helvetica, sans-serif;
        max-width: 960px;
        margin: 0 auto;
        float: none;
        background-color: #f8f8ff;
      }

      .ml-1 {
        margin-left: 1em;
      }

      .mt-3 {
        margin-top: 3rem;
      }

      .names {
        fill: none;
        stroke: #fff;
        stroke-linejoin: round;
      }

      .center {
        text-align: center;
      }

      .key {
        display: flex;
        justify-content: space-evenly;
        margin: 1rem;
      }
    </style>
    <title>Interactive Visulaization</title>
  </head>
  <body>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/queue.v1.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <div class="ml-1">
      <h1>Aid Effectiveness Visualizations</h1>
      <h5>By Jeremy Persing & Kaitlin Arens</h5>
      <div>
        <h2>
          What is the of percentage of people living below 50 percent of median
          income in countries around the world?
        </h2>
      </div>
    </div>

    <div id="div_template"></div>
    <div class="key">
      <span>
        <svg width="30" height="10">
          <g fill="rgb(0,0,0)">
            <rect width="10" height="10" />
          </g>
        </svg>
        No data given
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#ffb2b2">
            <rect width="10" height="10" />
          </g>
        </svg>
        0 - 5%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#ff7f7f">
            <rect width="10" height="10" />
          </g>
        </svg>
        5 - 10%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#ff4c4c">
            <rect width="10" height="10" />
          </g>
        </svg>
        10 - 15%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#ff1919">
            <rect width="10" height="10" />
          </g>
        </svg>
        15 - 20%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#cc0000">
            <rect width="10" height="10" />
          </g>
        </svg>
        20 - 25%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#7f0000">
            <rect width="10" height="10" />
          </g>
        </svg>
        25+%
      </span>
    </div>
    <div id="textbox" class="center"></div>
    <script>
      // var format = d3.format(",");

      // The world map
      var margin = { top: 0, right: 0, bottom: 0, left: 0 },
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

      // colors
      var color = d3
        .scaleThreshold()
        .domain([0, 5, 10, 15, 20, 25])
        .range([
          "rgb(0,0,0)",
          "#ffb2b2",
          "#ff7f7f",
          "#ff4c4c",
          "#ff1919",
          "#cc0000",
          "#7f0000",
        ]);

      var path = d3.geoPath();

      // rendering the map
      var svg = d3
        .select("#div_template")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("class", "map");

      var projection = d3
        .geoMercator()
        .scale(130)
        .translate([width / 2, height / 1.5]);

      var path = d3.geoPath().projection(projection);

      // svg.call(tip);
      var Tooltip = d3
        .select("#d3_template")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px");

      queue()
        .defer(d3.json, "world.geojson")
        // .defer(d3.tsv, "world_population.tsv")
        .defer(d3.csv, "poverty.csv")
        .await(ready);

      // data represents the map details from world.json
      // and poverty represents data from poverty.csv
      function ready(error, data, poverty) {
        var povertyById = {}; // holds average_value_Proportion of people living below 50 percent of median income (%) from poverty.csv
        console.log("data", data);
        console.log("poverty", poverty);

        poverty.forEach(function (d) {
          let percentage = {
            poverty:
              d[
                "average_value_Proportion of people living below 50 percent of median income (%)"
              ],
            year: d["Year"],
          };

          povertyById[d.id] = percentage;
        });

        data.features.forEach(function (d) {
          console.log("d", d);
          let povertyObj = povertyById[d.id];
          if (povertyObj) {
            d.poverty = povertyObj.poverty;
            d.year = povertyObj.year;
          } else {
            d.poverty = null;
            d.year = "No year given";
          }
        });

        svg
          .append("g")
          .attr("class", "countries")
          .selectAll("path")
          .data(data.features)
          .enter()
          .append("path")
          .attr("d", path)
          .style("fill", function (d) {
            let poverty = povertyById[d.id]?.poverty;
            if (!poverty) poverty = -1;
            console.log("poverty", poverty);
            return color(poverty);
          })
          .style("stroke", "white")
          .style("stroke-width", 1.5)
          .style("opacity", 0.8)
          // tooltips
          .style("stroke", "white")
          .style("stroke-width", 0.3)
          .on("mouseover", function (d) {
            let name = d.properties.name;
            let poverty = d.poverty;
            let year = d.year;

            if (poverty) poverty = poverty + "%";
            else poverty = "No data given";

            let string =
              "<strong>Country: </strong><span>" +
              name +
              "<br></span>" +
              "<strong>Year: </strong><span>" +
              year +
              "</span>" +
              "<br><strong>Proportion of people living below 50 " +
              "percent of median income: </strong><span>" +
              poverty;
            ("</span>");
            d3.select(this)
              .style("opacity", 1)
              .style("stroke", "white")
              .style("stroke-width", 3);
            // tip.show(d); comment
            d3.select("#textbox")
              .html("")
              .append("text")
              .html(() => string);
          })
          .on("mouseout", function (d) {
            // tip.hide(d); comment

            d3.select(this)
              .style("opacity", 0.8)
              .style("stroke", "white")
              .style("stroke-width", 0.3);
          });

        svg
          .append("path")
          .datum(
            topojson.mesh(data.features, function (a, b) {
              return a.id !== b.id;
            })
          )
          .attr("class", "names")
          .attr("d", path);
      }
    </script>

    <h2 class="ml-1 mt-3">
      What is the of percentage of people living in slums around the world?
    </h2>

    <div id="second_map"></div>
    <div class="key">
      <span>
        <svg width="30" height="10">
          <g fill="rgb(0,0,0)">
            <rect width="10" height="10" />
          </g>
        </svg>
        No data given
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#a1f7c1">
            <rect width="10" height="10" />
          </g>
        </svg>
        0 - 10%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#53e087">
            <rect width="10" height="10" />
          </g>
        </svg>
        10 - 20%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#02f25a">
            <rect width="10" height="10" />
          </g>
        </svg>
        20 - 30%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#06c44c">
            <rect width="10" height="10" />
          </g>
        </svg>
        30 - 40%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#02732c">
            <rect width="10" height="10" />
          </g>
        </svg>
        40 - 50%
      </span>
      <span>
        <svg width="30" height="10">
          <g fill="#034d1e">
            <rect width="10" height="10" />
          </g>
        </svg>
        50+%
      </span>
    </div>
    <div id="textbox2" class="center"></div>
    <script>
      // var format = d3.format(",");

      // The world map
      var margin = { top: 0, right: 0, bottom: 0, left: 0 },
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

      // colors
      var color2 = d3
        .scaleThreshold()
        .domain([0, 10, 20, 30, 40, 50])
        .range([
          "rgb(0,0,0)",
          "#a1f7c1",
          "#53e087",
          "#02f25a",
          "#06c44c",
          "#02732c",
          "#034d1e",
        ]);

      var path = d3.geoPath();

      // rendering the map
      var svg2 = d3
        .select("#second_map")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("class", "map");

      var projection = d3
        .geoMercator()
        .scale(130)
        .translate([width / 2, height / 1.5]);

      var path = d3.geoPath().projection(projection);

      // svg.call(tip);
      var Tooltip = d3
        .select("#d3_template")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px");

      queue()
        .defer(d3.json, "world.geojson")
        // .defer(d3.tsv, "world_population.tsv")
        .defer(d3.csv, "poverty.csv")
        .await(ready);

      // data represents the map details from world.json
      // and poverty represents data from poverty.csv
      function ready(error, data, poverty) {
        var slumsById = {}; // holds average_value_Proportion of people living below 50 percent of median income (%) from poverty.csv
        console.log("data", data);
        console.log("poverty", poverty);

        poverty.forEach(function (d) {
          let percentage2 = {
            poverty:
              d[
                "average_value_Population living in slums (% of urban population)"
              ],
            year: d["Year"],
          };

          slumsById[d.id] = percentage2;
        });

        data.features.forEach(function (d) {
          console.log("d", d);
          let povertyObj = slumsById[d.id];
          if (povertyObj) {
            d.poverty = povertyObj.poverty;
            d.year = povertyObj.year;
          } else {
            d.poverty = null;
            d.year = "No year given";
          }
        });

        svg2
          .append("g")
          .attr("class", "countries")
          .selectAll("path")
          .data(data.features)
          .enter()
          .append("path")
          .attr("d", path)
          .style("fill", function (d) {
            let poverty = slumsById[d.id]?.poverty;
            if (!poverty) poverty = -1;
            console.log("poverty", poverty);
            return color2(poverty);
          })
          .style("stroke", "white")
          .style("stroke-width", 1.5)
          .style("opacity", 0.8)
          // tooltips
          .style("stroke", "white")
          .style("stroke-width", 0.3)
          .on("mouseover", function (d) {
            let name = d.properties.name;
            let poverty = d.poverty;
            let year = d.year;

            if (poverty) poverty = poverty + "%";
            else poverty = "No data given";

            let string =
              "<strong>Country: </strong><span>" +
              name +
              "<br></span>" +
              "<strong>Year: </strong><span>" +
              year +
              "</span>" +
              "<br><strong>Average value of population " +
              "living in slums: </strong><span>" +
              poverty;
            ("</span>");
            d3.select(this)
              .style("opacity", 1)
              .style("stroke", "white")
              .style("stroke-width", 3);
            // tip.show(d); comment
            d3.select("#textbox2")
              .html("")
              .append("text")
              .html(() => string);
          })
          .on("mouseout", function (d) {
            // tip.hide(d); comment

            d3.select(this)
              .style("opacity", 0.8)
              .style("stroke", "white")
              .style("stroke-width", 0.3);
          });

        svg2
          .append("path")
          .datum(
            topojson.mesh(data.features, function (a, b) {
              return a.id !== b.id;
            })
          )
          .attr("class", "names")
          .attr("d", path);
      }

        
    </script>
    <div class="ml-1">
      <h5>
        Design Decisions: We chose our particular visual encodings based upon
        the data that we had which was closely tied to countries. The world map
        shows the different countries and by hovering the mouse over the desired
        location, the viewer can read that country's data. We believed this
        method was easier to interpret compared to a bar chart or sunburst
        diagram which would have to list all the countries as well as different
        color schemes for each data set which would be messier.
      </h5>
      <h5>
        Development Process: We researched some designs and Jeremy created the
        template for the graphs. We each created our own graph based on the data
        we were most interested in. With this in place, we then created a color
        scheme to highlight different ranges in the data. All together we spend
        about 6 hours in creating the project. Preparation/planning is what took
        the most time.
      </h5>
    </div>
  </body>
  <h5>Design Decisions: We chose our particular visual encodings based upon the data that we had which was closely tied to countries.  The world map shows the different 
    countries and by hovering the mouse over the desired location, the viewer can read that country's data. We believed this method was easier to interpret
    compared to a bar chart or sunburst diagram which would have to list all the countries as well as different color schemes for each data set which would 
    be messier.</h5>

    <h5>Development Process: We researched some designs and Jeremy created the template for the graphs. We each created our own graph based on the data we were most 
      interested in.  With this in place, we then created a color scheme to highlight different ranges in the data.  All together we spend about 6 hours in creating the project.  
      Preparation/planning is what took the most time.</h5>

 
      
      <div id="body">
        <body>
          <svg width="600" height="500"></svg>
          <script>
          
              var svg3 = d3.select("svg"),
                  margin = 200,
                  width = svg3.attr("width") - margin,
                  height = svg3.attr("height") - margin;
          
          
              var xScale = d3.scaleBand().range ([0, width]).padding(0.4),
                  yScale = d3.scaleLinear().range ([height, 0]);
          
              var g = svg3.append("g")
                         .attr("transform", "translate(" + 100 + "," + 100 + ")");
          
              d3.csv("climate-change.csv", function(d) {
                
                    
                  return {
                    avgEmission: d[ "average_value_CO2 emissions (metric tons per capita)"],
                    year: d["Year"],
                  };
                }).then(function(emissions) {
                  console.log(emissions);
                  
                 // emissionById[d.id] = p;
                  
                
                
                  xScale.domain(emissions.map(function(d) { return year; }));
                  yScale.domain([0, d3.max(emisssions, function(d) { return avgEmission; })]);
          
                  g.append("g")
                   .attr("transform", "translate(0," + height + ")")
                   .call(d3.axisBottom(xScale));
          
                  g.append("g")
                   .call(d3.axisLeft(yScale).tickFormat(function(d){
                       return "$" + d;
                   }).ticks(10))
                   .append("text")
                   .attr("y", 6)
                   .attr("dy", "0.71em")
                   .attr("text-anchor", "end")
                   .text("value");
          });
          </script>
          </body>
      
      <!-- <div id="charts">         -->
        <!-- <div id="hour-chart" class="chart"> 
          <div class="title">Time of Day</div>
        </div>
        <div id="delay-chart" class="chart">
          <div class="title">Arrival Delay (min.)</div>
        </div>
        <div id="distance-chart" class="chart">
          <div class="title">Distance (mi.)</div>
        </div>-->
        <!-- <div id="date-chart" class="chart"> -->
          <!-- <div class="title">Date</div> -->
        <!-- </div> -->
      <!-- </div> -->
      
      <!-- <aside id="totals"><span id="active">-</span> of <span id="total">-</span> flights selected.</aside> -->
      
      <!-- <div id="lists"> 
        <div id="flight-list" class="list"></div>
      </div>-->
      
      <!-- </div> -->
      
      
      <script src="crossfilter.v1.min.js"></script>
      <script src="d3.v3.min.js"></script>
      <script>
      
      // (It's CSV, but GitHub Pages only gzip's JSON at the moment.)   .defer(d3.csv, "poverty.csv")
      /*d3.csv("poverty.json", function(error, poverty) {
      
        // Various formatters.
        var formatNumber = d3.format(",d"),
            formatChange = d3.format("+,d"),
            formatDate = d3.time.format("%B %d, %Y"),
            formatTime = d3.time.format("%I:%M %p");
      
        // A nest operator, for grouping the flight list.
        var nestByDate = d3.nest()
            .key(function(d) { return d3.time.day(d.date); });
      
        // A little coercion, since the CSV is untyped.
        flights.forEach(function(d, i) {
          d.index = i;
          d.date = parseDate(d.date);
          d.delay = +d.delay;
          d.distance = +d.distance;
        });
      
        // Create the crossfilter for the relevant dimensions and groups.
        var new_pov = crossfilter(emissions),
            all = new_pov.groupAll(),
            year = new_pov.dimension(function(d) { return d.year; }),
            dates = date.group(d3.time.day),
            //hour = new_pov.dimension(function(d) { return d.date.getHours() + d.date.getMinutes() / 60; }),
            //hours = hour.group(Math.floor),
            //delay = flight.dimension(function(d) { return Math.max(-60, Math.min(149, d.delay)); }),
            //delays = delay.group(function(d) { return Math.floor(d / 10) * 10; }),
            //distance = flight.dimension(function(d) { return Math.min(1999, d.distance); }),
            //distances = distance.group(function(d) { return Math.floor(d / 50) * 50; });
      
        var charts = [
      
          /*barChart()
              .dimension(hour)
              .group(hours)
            .x(d3.scale.linear()
              .domain([0, 24])
              .rangeRound([0, 10 * 24])),
      
          barChart()
              .dimension(delay)
              .group(delays)
            .x(d3.scale.linear()
              .domain([-60, 150])
              .rangeRound([0, 10 * 21])),
      
          barChart()
              .dimension(distance)
              .group(distances)
            .x(d3.scale.linear()
              .domain([0, 2000])
              .rangeRound([0, 10 * 40])),*/
      
          /*barChart()
              .dimension(year)
              .group(dates)
              .round(d3.time.day.round)
            .x(d3.time.scale()
              .domain([new Date(1969), new Date(2020)])
              .rangeRound([0, 10 * 90]))
              .filter([new Date(1969), new Date(2020)])
      
        ];
      
        // Given our array of charts, which we assume are in the same order as the
        // .chart elements in the DOM, bind the charts to the DOM and render them.
        // We also listen to the chart's brush events to update the display.
        var chart = d3.selectAll(".chart")
            .data(charts)
            .each(function(chart) { chart.on("brush", renderAll).on("brushend", renderAll); });
      
        // Render the initial lists.
        var list = d3.selectAll(".list")
            .data([flightList]);
      
        // Render the total.
        d3.selectAll("#total")
            .text(formatNumber(flight.size()));
      
        renderAll();
      
        // Renders the specified chart or list.
        function render(method) {
          d3.select(this).call(method);
        }
      
        // Whenever the brush moves, re-rendering everything.
        function renderAll() {
          chart.each(render);
          list.each(render);
          d3.select("#active").text(formatNumber(all.value()));
        }
      
        // Like d3.time.format, but faster.
        /*function parseDate(d) {
          return new Date(2001,
              d.substring(0, 2) - 1,
              d.substring(2, 4),
              d.substring(4, 6),
              d.substring(6, 8));
        }*/
      
        /*window.filter = function(filters) {
          filters.forEach(function(d, i) { charts[i].filter(d); });
          renderAll();
        };
      
        window.reset = function(i) {
          charts[i].filter(null);
          renderAll();
        };
      
        /*function flightList(div) {
          var flightsByDate = nestByDate.entries(date.top(40));
      
          div.each(function() {
            var date = d3.select(this).selectAll(".date")
                .data(flightsByDate, function(d) { return d.key; });
      
            date.enter().append("div")
                .attr("class", "date")
              .append("div")
                .attr("class", "day")
                .text(function(d) { return formatDate(d.values[0].date); });
      
            date.exit().remove();
      
            var flight = date.order().selectAll(".flight")
                .data(function(d) { return d.values; }, function(d) { return d.index; });
      
            var flightEnter = flight.enter().append("div")
                .attr("class", "flight");
      
            flightEnter.append("div")
                .attr("class", "time")
                .text(function(d) { return formatTime(d.date); });
      
            flightEnter.append("div")
                .attr("class", "origin")
                .text(function(d) { return d.origin; });
      
            flightEnter.append("div")
                .attr("class", "destination")
                .text(function(d) { return d.destination; });
      
            flightEnter.append("div")
                .attr("class", "distance")
                .text(function(d) { return formatNumber(d.distance) + " mi."; });
      
            flightEnter.append("div")
                .attr("class", "delay")
                .classed("early", function(d) { return d.delay < 0; })
                .text(function(d) { return formatChange(d.delay) + " min."; });
      
            flight.exit().remove();
      
            flight.order();
          });
        }*/
      
        /*function barChart() {
          if (!barChart.id) barChart.id = 0;
      
          var margin = {top: 10, right: 10, bottom: 20, left: 10},
              x,
              y = d3.scale.linear().range([100, 0]),
              id = barChart.id++,
              axis = d3.svg.axis().orient("bottom"),
              brush = d3.svg.brush(),
              brushDirty,
              dimension,
              group,
              round;
      
          function chart(div) {
            var width = x.range()[1],
                height = y.range()[0];
      
            y.domain([0, group.top(1)[0].value]);
      
            div.each(function() {
              var div = d3.select(this),
                  g = div.select("g");
      
              // Create the skeletal chart.
              if (g.empty()) {
                div.select(".title").append("a")
                    .attr("href", "javascript:reset(" + id + ")")
                    .attr("class", "reset")
                    .text("reset")
                    .style("display", "none");
      
                g = div.append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                  .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      
                g.append("clipPath")
                    .attr("id", "clip-" + id)
                  .append("rect")
                    .attr("width", width)
                    .attr("height", height);
      
                g.selectAll(".bar")
                    .data(["background", "foreground"])
                  .enter().append("path")
                    .attr("class", function(d) { return d + " bar"; })
                    .datum(group.all());
      
                g.selectAll(".foreground.bar")
                    .attr("clip-path", "url(#clip-" + id + ")");
      
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(axis);
      
                // Initialize the brush component with pretty resize handles.
                var gBrush = g.append("g").attr("class", "brush").call(brush);
                gBrush.selectAll("rect").attr("height", height);
                gBrush.selectAll(".resize").append("path").attr("d", resizePath);
              }
      
              // Only redraw the brush if set externally.
              if (brushDirty) {
                brushDirty = false;
                g.selectAll(".brush").call(brush);
                div.select(".title a").style("display", brush.empty() ? "none" : null);
                if (brush.empty()) {
                  g.selectAll("#clip-" + id + " rect")
                      .attr("x", 0)
                      .attr("width", width);
                } else {
                  var extent = brush.extent();
                  g.selectAll("#clip-" + id + " rect")
                      .attr("x", x(extent[0]))
                      .attr("width", x(extent[1]) - x(extent[0]));
                }
              }
      
              g.selectAll(".bar").attr("d", barPath);
            });
      
            function barPath(groups) {
              var path = [],
                  i = -1,
                  n = groups.length,
                  d;
              while (++i < n) {
                d = groups[i];
                path.push("M", x(d.key), ",", height, "V", y(d.value), "h9V", height);
              }
              return path.join("");
            }
      
            function resizePath(d) {
              var e = +(d == "e"),
                  x = e ? 1 : -1,
                  y = height / 3;
              return "M" + (.5 * x) + "," + y
                  + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
                  + "V" + (2 * y - 6)
                  + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
                  + "Z"
                  + "M" + (2.5 * x) + "," + (y + 8)
                  + "V" + (2 * y - 8)
                  + "M" + (4.5 * x) + "," + (y + 8)
                  + "V" + (2 * y - 8);
            }
          }
      
          brush.on("brushstart.chart", function() {
            var div = d3.select(this.parentNode.parentNode.parentNode);
            div.select(".title a").style("display", null);
          });
      
          brush.on("brush.chart", function() {
            var g = d3.select(this.parentNode),
                extent = brush.extent();
            if (round) g.select(".brush")
                .call(brush.extent(extent = extent.map(round)))
              .selectAll(".resize")
                .style("display", null);
            g.select("#clip-" + id + " rect")
                .attr("x", x(extent[0]))
                .attr("width", x(extent[1]) - x(extent[0]));
            dimension.filterRange(extent);
          });
      
          brush.on("brushend.chart", function() {
            if (brush.empty()) {
              var div = d3.select(this.parentNode.parentNode.parentNode);
              div.select(".title a").style("display", "none");
              div.select("#clip-" + id + " rect").attr("x", null).attr("width", "100%");
              dimension.filterAll();
            }
          });
      
          chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin = _;
            return chart;
          };
      
          chart.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            axis.scale(x);
            brush.x(x);
            return chart;
          };
      
          chart.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
          };
      
          chart.dimension = function(_) {
            if (!arguments.length) return dimension;
            dimension = _;
            return chart;
          };
      
          chart.filter = function(_) {
            if (_) {
              brush.extent(_);
              dimension.filterRange(_);
            } else {
              brush.clear();
              dimension.filterAll();
            }
            brushDirty = true;
            return chart;
          };
      
          chart.group = function(_) {
            if (!arguments.length) return group;
            group = _;
            return chart;
          };
      
          chart.round = function(_) {
            if (!arguments.length) return round;
            round = _;
            return chart;
          };
      
          return d3.rebind(chart, brush, "on");
        }
      });*/
    
      </script>
      

</html>
</html>
